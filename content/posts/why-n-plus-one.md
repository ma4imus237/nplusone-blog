---
title: "Why n+1"
date: 2025-01-19
author: "Massimo"
description: "The mathematical idea behind the name, from Peano's successor function to the inductive step, and why every next thing matters."
lang: "en"
draft: false
---

A blog needs a name. Most names are arbitrary. This one is not.

**n+1** is borrowed from mathematics, specifically from the places where the idea of *the next thing* is formalized. It shows up in the foundations of arithmetic, in proof techniques, and in the structure of infinite series. In each case, it carries the same meaning: what comes after is defined by what came before.

This post is an attempt to explain the name properly, not as a tagline, but as an idea worth understanding on its own terms.

## The successor function

In the late nineteenth century, Giuseppe Peano set out to define the natural numbers from first principles. The question he was answering sounds almost absurd: what *are* the numbers 0, 1, 2, 3, ...? Everyone uses them. Nobody had rigorously defined them.

Peano's axioms begin with a single element, zero, and a single operation: the **successor function** S. For any natural number n, S(n) = n + 1. That is the entire mechanism. Zero exists. Everything else is constructed.

From this one operation, the natural numbers emerge. One is S(0). Two is S(S(0)). Three is S(S(S(0))). There is no table of numbers to memorize, no appeal to intuition. The entire infinite set is generated by applying the same rule, *take what you have and add one*, over and over, without end.

What makes this remarkable is not the complexity of the construction but the absence of it. Addition, multiplication, exponentiation, all of arithmetic, can be derived from the successor function and nothing else. It is the most minimal generative rule in mathematics: given any n, produce n + 1.

The idea is striking in its economy. You do not need to define infinity. You only need to define the next step, and infinity follows. The successor function does not know about large numbers. It does not plan ahead. It produces exactly one thing, the next number, and that is sufficient.

There is a lesson in this. The most powerful structures are not always the most elaborate ones. Sometimes the simplest rule, applied consistently, generates more than any grand design could.

## Mathematical induction

If the successor function builds the numbers, **induction** is the tool that reasons about them.

The principle is this: suppose a statement P holds for some base case, say P(0). Now suppose that whenever P(n) is true, P(n + 1) is also true. Then P holds for every natural number.

Two conditions. A starting point and a rule of propagation. The base case anchors the argument; the inductive step, the transition from n to n + 1, carries it forward across all cases. No enumeration required. No exhaustive checking. One well-constructed step from n to n + 1 is enough to cover the infinite.

The elegance of induction lies in what it *does not* require. You never need to inspect each case individually. You never need to see the whole picture. You only need to prove that the mechanism of propagation works, that the bridge from n to n + 1 holds, and the conclusion cascades forward without limit.

This is the same economy as the successor function, transposed into logic. Where S(n) builds numbers one at a time, induction proves truths one step at a time. Both operate locally, at the boundary between n and n + 1, and both achieve global results.

Consider the classic example: proving that the sum of the first n natural numbers equals n(n + 1) / 2. The base case is trivial, the sum of zero numbers is zero. The inductive step shows that if the formula holds for n, adding n + 1 preserves it. That single step, verified once, covers every natural number that will ever exist.

Induction is not merely a proof technique. It is a way of thinking. It says: you do not need to see the entire landscape. You need to see where you are and how to move forward. The rest follows.

## Series and sequences

The notation appears again in analysis. A **sequence** is an ordered list of terms: a(0), a(1), a(2), and so on. Each term a(n+1) is the successor of a(n), and the relationship between consecutive terms defines the character of the sequence, whether it converges, diverges, oscillates, or grows without bound.

Some sequences are defined explicitly, a(n) = 1/n, for instance. Others are defined **recursively**: to compute a(n+1), you need a(n). The Fibonacci sequence is the canonical example: each term is the sum of the two preceding terms. There is no shortcut. You cannot jump to the hundredth Fibonacci number without computing the ninety-nine that came before it. The sequence is its own history.

Taylor series make the idea particularly vivid. A function, say, the exponential function or the sine, can be approximated by a polynomial. Each additional term in the polynomial, each n + 1, refines the approximation. The first term gives a constant. The second adds a slope. The third introduces curvature. The fourth captures inflection. With enough terms, the polynomial begins to mirror the original function with arbitrary precision.

What matters is the *direction* of the process. Each term does not merely add volume. It adds **resolution**. The approximation does not just grow, it sharpens. And the difference between the n-th approximation and reality shrinks with every step, often exponentially.

The pattern is always the same: each increment carries information. Each n + 1 is not just *more*, it is *closer*.

## Iteration in practice

Outside of pure mathematics, the pattern of n + 1 appears wherever systems improve through repetition.

Software development is built on iteration. Version 1.0 ships with known limitations. Version 1.1 fixes the most critical bugs. Version 1.2 adds the feature that users actually needed. Each release is n + 1, not a reinvention, but a refinement. The best software is not designed in a single act of genius. It is *evolved* through accumulated increments, each one informed by the failures and successes of the last.

Scientific knowledge works the same way. A hypothesis is proposed, tested, revised. Newton's mechanics was the n to Einstein's n + 1. Einstein's theory was the n to quantum field theory's n + 1. No theory is final. Each is the best approximation available until the next term in the series arrives.

Even writing follows this pattern. A first draft is a base case, rough, incomplete, but *existent*. Each revision is an inductive step, carrying the text closer to what it ought to be. Experienced writers know that the quality of the final draft has less to do with the quality of the first draft and more to do with the number and rigor of the iterations between them.

## The philosophy

This is why the blog is called **n+1**.

Writing is an iterative process. Each post is the next term in a sequence that I cannot see the end of. Some posts will be base cases, initial explorations of a topic, planted without knowing where the argument leads. Others will be inductive steps, building on earlier ideas, refining them, occasionally correcting them.

The name is a commitment to **incrementalism**. Not to perfection, not to completeness, but to the discipline of producing the next thing. The successor function does not ask whether n is large enough or interesting enough. It simply produces n + 1. The inductive step does not require you to solve the general case directly. It only requires you to show how to get from here to there.

There is a deeper resonance too. Peano's construction implies that every natural number, no matter how large, was once the *next* number, the n + 1 to some predecessor. Significance is retrospective. You cannot know which term in the sequence will matter most until the sequence has been written.

And there is comfort in the constraint. The commitment is not to write something brilliant. It is not to produce the definitive take on any subject. It is only to write the *next* thing, to apply the successor function one more time, and trust that the sequence, over time, will converge on something worth reading.

So the only productive strategy is the obvious one: write the next post.
